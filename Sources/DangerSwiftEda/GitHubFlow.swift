//
//  GitHubFlow.swift
//  
//
//  Created by 史 翔新 on 2022/10/27.
//

import Foundation
import DangerSwiftShoki

// MARK: - GitHubFlow Declaration
public struct GitHubFlow {
    
    public enum Branch {
        case main
        case working
        case ci
    }
    
    public struct Configuration {
        
        public enum ChangeLogUpdateRequirement {
            case no
            case yes(path: String)
        }
        
        public var branchParsingMethod: (String) -> GitHubFlow.Branch?
        public var acceptsMergeCommitsInPRs: Bool
        public var recommendedMaxDiffAmountInPRs: Int
        public var suggestsChangeLogUpdate: ChangeLogUpdateRequirement
        
        public init(
            branchParsingMethod: @escaping (String) -> GitHubFlow.Branch? = GitHubFlow.Branch.defaultParsingMethod(name:),
            acceptsMergeCommitsInPRs: Bool = false,
            recommendedMaxDiffAmountInPRs: Int = 300,
            suggestsChangeLogUpdate: ChangeLogUpdateRequirement = .yes(path: "CHANGELOG.md")
        ) {
            self.branchParsingMethod = branchParsingMethod
            self.acceptsMergeCommitsInPRs = acceptsMergeCommitsInPRs
            self.recommendedMaxDiffAmountInPRs = recommendedMaxDiffAmountInPRs
            self.suggestsChangeLogUpdate = suggestsChangeLogUpdate
        }
        
        public static var `default`: Configuration {
            .init()
        }
        
    }
    
    public var configuration: Configuration
    
    public init(configuration: Configuration) {
        self.configuration = configuration
    }
    
    @available(*, deprecated, renamed: "init(configuration:)")
    public init(_ configuration: Configuration) {
        self.init(configuration: configuration)
    }
    
}

// MARK: - Methods for single check items
extension GitHubFlow {
    
    // Check whether base branch is correct or not
    private func checkBaseBranch(in pr: PRMetaData, into report: inout Report, using utility: PRUtility) {
        
        let doBaseBranchCheckTitle = "Base Branch Check"
        utility.check(doBaseBranchCheckTitle, into: &report) {
            guard let baseBranch = configuration.branchParsingMethod(pr.baseBranchName) else {
                assertionFailure("Failed to get base branch")
                return .rejected(failureMessage: "Invalid base branch")
            }
            
            switch baseBranch {
            case .main:
                return .good
                
            case .working, .ci:
                return .rejected(failureMessage: "Invalid base branch")
            }
            
        }
        
    }
    
    // Check whether the PR contains merge commits or not
    func checkNoMergeCommitsIncluded(in pr: PRMetaData, into report: inout Report, using utility: PRUtility) {
        
        let doNoMergeCommitsCheckTitle = "Merge Commit Non-Existence Check"
        utility.check(doNoMergeCommitsCheckTitle, into: &report) {
            if pr.commits.allSatisfy({ !$0.isMergeCommit }) {
                return .good
                
            } else {
                return .rejected(failureMessage: "Don't include any merge commits in this PR. Please consider rebasing if needed.")

            }
        }
        
    }
    
    // Check whether the PR volume is less than a given number
    func checkDiffAmount(in pr: PRMetaData, lessThan maxAmountOfModifiedLines: Int, into report: inout Report, using utility: PRUtility) {
        
        let doDiffAmountCheckTitle = "Diff Volume Check"
        utility.check(doDiffAmountCheckTitle, into: &report) {
            if pr.modifiedLines < maxAmountOfModifiedLines {
                return .good
                
            } else {
                return .acceptable(warningMessage: "There's too much diff. Please make PRs smaller.")
            }
        }
        
    }
    
    // Check whether ChangeLog has been modified or not
    func checkChangeLogModification(in pr: PRMetaData, filePath: String, into report: inout Report, using utility: PRUtility) {
        
        let doChangeLogModificationCheckTitle = "ChangeLog Modification Check"
        let hasChangeLogBeenModified = pr.hasModifiedFile(at: filePath)
        
        utility.check(doChangeLogModificationCheckTitle, into: &report) {
            if hasChangeLogBeenModified {
                return .good
                
            } else {
                return .acceptable(warningMessage: "This PR doesn't contain any modifications at \(filePath). Please consider to update the ChangeLog.")
            }
        }
        
    }
    
    // Ask reviewers to check whether CI auto generated diff is valid or not
    func checkCIAutoPRModification(into report: inout Report, using utility: PRUtility) {
        
        utility.askReviewer(to: "Check whether CI's auto-generated PR is valid or not", into: &report)
        utility.warn("This PR is auto-generated by CI service. Please check if the diff is valid or not.")
        
    }
    
    // Ask reviewers to check whether all required tasks are closed
    func checkRemainedTasksState(into report: inout Report, using utility: PRUtility) {
        
        utility.askReviewer(to: "Remained Task Check", into: &report)
        utility.warn("Please check whether all required tickets and issues are closed or not.")
        
    }
    
}

// MARK: - Methods for each workflow of PRs
extension GitHubFlow {
    
    func doCIServicePRCheck(against pr: PRMetaData, using utility: PRUtility) -> Report {
        
        var report = utility.makeInitialReport(title: "CI Service PR Check")
        
        checkBaseBranch(in: pr, into: &report, using: utility)
        
        // CI auto-generated PRs should not contain any merge commits at first place.
        checkNoMergeCommitsIncluded(in: pr, into: &report, using: utility)
        
        checkCIAutoPRModification(into: &report, using: utility)
        
        return report
        
    }
    
    func doWorkingPRCheck(against pr: PRMetaData, using utility: PRUtility) -> Report {
        
        var report = utility.makeInitialReport(title: "Feature PR Check")
        
        checkBaseBranch(in: pr, into: &report, using: utility)
        
        if !configuration.acceptsMergeCommitsInPRs {
            checkNoMergeCommitsIncluded(in: pr, into: &report, using: utility)
        }
        
        checkDiffAmount(in: pr, lessThan: configuration.recommendedMaxDiffAmountInPRs, into: &report, using: utility)
        
        if case .yes(path: let filePath) = configuration.suggestsChangeLogUpdate {
            checkChangeLogModification(in: pr, filePath: filePath, into: &report, using: utility)
        }
        
        return report
        
    }
    
}

// MARK: - GitHubFlow Check
extension GitHubFlow: PRWorkflow {
    
    public enum FlowError: Error {
        case invalidHeadBranch(name: String)
        case illegalHeadBranch(Branch)
    }
    
    public func doWorkflowCheck(against pr: PRMetaData, using utility: PRUtility) throws -> Report {
        
        let headBranchName = pr.headBranchName
        guard let headBranch = configuration.branchParsingMethod(headBranchName) else {
            throw FlowError.invalidHeadBranch(name: headBranchName)
        }
        
        switch headBranch {
        case .ci:
            return doCIServicePRCheck(against: pr, using: utility)
            
        case .working:
            return doWorkingPRCheck(against: pr, using: utility)
            
        case .main:
            throw FlowError.illegalHeadBranch(headBranch)
        }
   

    }
    
}

// MARK: - Convenient Extensions
extension GitHubFlow.Branch {
    
    public static func defaultParsingMethod(name: String) -> Self? {
        
        switch name {
        case "main", "master":
            return .main
            
        case "ci":
            return .ci
            
        case let ci where ci.contains(pattern: #"\bci\b[/-]"#):
            return .ci
            
        default:
            return .working
        }
        
    }
}
